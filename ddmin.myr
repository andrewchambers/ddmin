// A test case reduction program by Andrew Chambers
// using the minimizing delta debugging algorithm from
// Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-Inducing Input

use std
use bio

var chunks : byte[:][:]
var testfile : byte[:]
var tester : byte[:]

type result = union 
    `Interesting
    `Boring
;;

const ddmin = {test
    -> ddmin2(test, 2)
}

const cleanuptests = {tests
    for test in tests
        std.bsfree(test)
    ;;
    std.slfree(tests)
}

const ddmin2 = {test, n
    // XXX mc bug? cannot use this label...
    // :tailrecurse
    
    var compliments : std.bitset#[:] = [][:]
    var vals = [][:]
    var ntestvals = 0

    for v in std.bybsvalue(test)
        std.slpush(&vals, v)
        ntestvals += 1
    ;;
    
    var partsz = vals.len / n
    
    for var i = 0; i < vals.len && partsz != 0; i += partsz
        var subtest = std.mkbs()
        for var j = 0 ; j < partsz && i+j < vals.len; j++
            std.bsput(subtest, vals[i + j])
        ;;

        match runtest(subtest)
        | `Interesting:
            cleanuptests(compliments)
            std.slfree(vals)
            std.bsfree(test)
            test = subtest
            n = 2
            //goto tailrecurse
            -> ddmin2(test, n)
        | `Boring:
            var compliment = std.bsdup(test)
            std.bsdiff(compliment, subtest)
            std.bsfree(subtest)
            std.slpush(&compliments, compliment)
        ;;
    ;;

    std.slfree(vals)
    
    for compliment in compliments
        match runtest(compliment)
        | `Interesting:
            std.bsfree(test)
            test = std.bsdup(compliment)
            cleanuptests(compliments)
            n = 2
            //goto tailrecurse
            -> ddmin2(test, n)
        | `Boring:
        ;;
    ;;
    cleanuptests(compliments)

    if n < ntestvals
        n = std.min(ntestvals, 2*n)
        //goto tailrecurse
        -> ddmin2(test, n)
    ;;
    
    spittest(test)
    std.bsfree(test)
    -> void
}

var resultcache : std.htab(std.bitset#, result)#

const __init__ = {
    // XXX: make this hash function better?
    const bshash = {bs; -> (std.bscount(bs) : uint32) ^ (std.bsmax(bs) : uint32)}
    resultcache = std.mkht(bshash, std.bseq)
}


const runtest = {test : std.bitset#
    match std.htget(resultcache, test)
    | `std.Some r:
        -> r
    | `std.None:
    ;;
    
    spittest(test)
    
    var pid = std.fork()
    
    if pid == 0
        std.execvp(tester, [][:])
        std.fatal("error executing {}!\n", tester)
    ;;
    
    var result = `Boring
    
    match std.wait(pid)
    | `std.Wsuccess:
        result = `Interesting
    | _:
    ;;
    
    std.htput(resultcache, std.bsdup(test), result)
    -> result
}

const spittest = {test : std.bitset#
    // XXX: Write the test with the same permissions it started with.
    var f = std.try(bio.create(testfile, bio.Wr, 0o755))
    
    for var i = 0; i < chunks.len; i++
        if std.bshas(test, i)
            match bio.write(f, chunks[i])
            | `bio.Ok n:
                if chunks[i].len != n
                    std.fatal("error writing test case\n")
                ;;
            | _:
                std.fatal("error writing test case\n")
            ;;
        ;;
    ;;
    
    if !bio.close(f)
        std.fatal("error closing writing test file\n")
    ;;
}

const loadtestchunks = {chars
    var f = std.try(bio.open(testfile, bio.Rd))
   
    while true
        if chars
            match bio.getb(f)
            | `bio.Ok b:
                std.slpush(&chunks, std.sldup([b][:]))
            | `bio.Eof:
                break
            | `bio.Err ioerr:
                std.fatal("error reading input line: {}\n", ioerr)
            ;;
        else
            match bio.readto(f, "\n")
            | `bio.Ok ln:
                // XXX maybe these stdlib functions should keep the delim
                // XXX we are adding a \n even when we don't want one at EOF...
                var lndup = std.sldup(ln)
                std.slfree(ln)
                std.sljoin(&lndup, "\n")
                std.slpush(&chunks, lndup)
            | `bio.Eof:
                break
            | `bio.Err ioerr:
                std.fatal("error reading input line: {}\n", ioerr)
            ;;
        ;;
   ;;
    
    if !bio.close(f)
        std.fatal("error closing test file\n")
    ;;
}

const main = { args : byte[:][:]
    
    var cmd = std.optparse(args, &[
        .argdesc = "tester testfile",
        .minargs = 2,
        .maxargs = 2,
        .opts = [
            [.opt='c', .desc="minimise chars instead of lines"],
        ][:]
    ])
    var chars = false

    for opt in cmd.opts
        match opt
        | ('c', ""):
            chars = true
        | _:
            std.die("unreachable\n")
        ;;
    ;;

    tester = cmd.args[0]
    testfile = cmd.args[1]

    loadtestchunks(chars)
        
    var initialtest = std.mkbs()
    for var i = 0; i < chunks.len; i++
        std.bsput(initialtest, i) 
    ;;

    match runtest(initialtest)
    | `Boring:
        std.fatal("unmodified test case was boring, aborting.\n")
    | `Interesting:
    ;;
    
    ddmin(initialtest)
}
