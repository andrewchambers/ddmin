// A test case reduction program by Andrew Chambers
// using the minimizing delta debugging algorithm from
// Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-Inducing Input

use std
use bio

var chunks : byte[:][:]
var testfile : byte[:]
var tester : byte[:]

type result = union 
    `Interesting
    `Boring
;;

const ddmin = {test
    -> ddmin2(test, 2)
}

const ddmin2 = {test, n
    // XXX mc bug? cannot use this label...
    // :tailrecurse
    
    var subtests = partition(test, n)
    
    var cleanupsubtestsexcept = {retain
        for subtest in subtests
            if subtest != retain
                std.bsfree(subtest)
            ;;
        ;;
        std.slfree(subtests)
    }
    
    var cleanup = {
        cleanupsubtestsexcept((0 : std.bitset#))
        std.bsfree(test)
    }
    
    for subtest in subtests
        match runtest(subtest)
        | `Interesting:
            std.bsfree(test)
            cleanupsubtestsexcept(subtest)
            test = subtest
            n = 2
            //goto tailrecurse
            -> ddmin2(test, n)
        | `Boring:
        ;;
    ;;
    
    for subtest in subtests
        var compliment = std.bsdup(test)
        std.bsdiff(compliment, subtest)
        match runtest(compliment)
        | `Interesting:
            cleanup()
            test = compliment
            n = std.max(n - 1, 2)
            //goto tailrecurse
            -> ddmin2(test, n)
        | `Boring:
            std.bsfree(compliment)
        ;;
    ;;
    
    var count = std.bscount(test)
    if n < count
        cleanupsubtestsexcept((0 : std.bitset#))
        n = std.min(count, 2*n)
        //goto tailrecurse
        -> ddmin2(test, n)
    ;;
    
    spittest(test)
    cleanup()
    -> void
}

const partition = {test, n
    var partitions : std.bitset#[:] = [][:]
    var vals = [][:]
    
    for v in std.bybsvalue(test)
        std.slpush(&vals, v)
    ;;
    
    var partsz = vals.len / n
    
    for var i = 0; i < vals.len && partsz != 0; i += partsz
        std.slpush(&partitions, std.mkbs())
        for var j = 0 ; j < partsz && i+j < vals.len; j++
            std.bsput(partitions[partitions.len-1], vals[i + j])
        ;;
    ;;
    
    std.slfree(vals)
    
    -> partitions
}

const runtest = {test : std.bitset#
    spittest(test)
    
    var pid = std.fork()
    
    if pid == 0
        std.execvp(tester, [][:])
        std.fatal("error executing {}!\n", tester)
    ;;
    
    match std.wait(pid)
    | `std.Wsuccess:
        -> `Interesting
    | _:
        -> `Boring
    ;;
}

const spittest = {test : std.bitset#
    // XXX: Write the test with the same permissions it started with.
    var f = std.try(bio.create(testfile, bio.Wr, 0o755))
    
    for var i = 0; i < chunks.len; i++
        if std.bshas(test, i)
            match bio.write(f, chunks[i])
            | `bio.Ok n:
                if chunks[i].len != n
                    std.fatal("error writing test case\n")
                ;;
            | _:
                std.fatal("error writing test case\n")
            ;;
        ;;
    ;;
    
    if !bio.close(f)
        std.fatal("error closing writing test file\n")
    ;;
}

const loadtestchunks = {chars
    var f = std.try(bio.open(testfile, bio.Rd))
   
    while true
        if chars
            match bio.getb(f)
            | `bio.Ok b:
                std.slpush(&chunks, std.sldup([b][:]))
            | `bio.Eof:
                break
            | `bio.Err ioerr:
                std.fatal("error reading input line: {}\n", ioerr)
            ;;
        else
            match bio.readto(f, "\n")
            | `bio.Ok ln:
                // XXX maybe these stdlib functions should keep the delim
                // XXX we are adding a \n even when we don't want one at EOF...
                var lndup = std.sldup(ln)
                std.slfree(ln)
                std.sljoin(&lndup, "\n")
                std.slpush(&chunks, lndup)
            | `bio.Eof:
                break
            | `bio.Err ioerr:
                std.fatal("error reading input line: {}\n", ioerr)
            ;;
        ;;
   ;;
    
    if !bio.close(f)
        std.fatal("error closing test file\n")
    ;;
}

const main = { args : byte[:][:]
    
    var cmd = std.optparse(args, &[
        .argdesc = "tester testfile",
        .minargs = 2,
        .maxargs = 2,
        .opts = [
            [.opt='c', .desc="minimise chars instead of lines"],
        ][:]
    ])
    var chars = false

    for opt in cmd.opts
        match opt
        | ('c', ""):
            chars = true
        | _:
            std.die("unreachable\n")
        ;;
    ;;

    tester = cmd.args[0]
    testfile = cmd.args[1]

    loadtestchunks(chars)
        
    var initialtest = std.mkbs()
    for var i = 0; i < chunks.len; i++
        std.bsput(initialtest, i) 
    ;;

    match runtest(initialtest)
    | `Boring:
        std.fatal("unmodified test case was boring, aborting.\n")
    | `Interesting:
    ;;
    
    ddmin(initialtest)
}
